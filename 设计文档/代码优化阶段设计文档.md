# 代码优化阶段设计文档

### 7.1 常数优化

在代码生成的过程中，如果标识符对应的是常数，则在大多数的情况下可以进行一定的优化。

- 加减法运算中，遇到一个操作数为常数时，可以用addi和subi
- 乘除法运算中，遇到操作数中有0或1的情况可以进行简化，例如x\*1、x*0、x/1、0/x等情况下可以不进行调用乘除操作就得到相应的运算结果
- 条件跳转语句中，如条件两边均为常数，可以直接得出结果以判断是否跳转
- 运算过程中可以使用$0寄存器替代数字0
- 数组调用以及数组赋值过程中，若数组下标为常数，可以直接计算出正确的地址

通过用常数替换从内存中获取数据并用寄存器参与运算的过程，可以节省大量的load操作的时间。



### 7.2 内联函数优化

对于没有跳转语句、函数调用语句、数组引用的函数，可以使用内联函数进行优化，从而减少函数调用带来的跳转等必然消耗。通过内联函数优化，可以节省很多保存现场的时间，此外还可以减少很多参数传递操作所需要的时间。当该函数位于循环语句中，内敛优化的效果会格外明显。

在进行函数内联之前，我们需要对原函数中的变量名进行预处理，如果是原函数的局部变量则需要重命名并加入到外层函数的符号表中，如果是全局变量则不需要进行处理。



### 7.3 临时寄存器优化

对于临时寄存器，可以建立寄存器池对临时寄存器进行统一分配。当遇到新的未分配寄存器的变量时从寄存器池中获取新的寄存器，当遇到所有的寄存器都已经被使用的情况时，则需要考虑释放寄存器。在释放寄存器的同时，要按照寄存器对应的变量是否被改写判断寄存器中的值是否需要写回内存。当一个基本块结束时，我们需要释放所有的临时寄存器。



### 7.4 全局寄存器优化

对于全局寄存器，我们可以通过理论课上所讲的引用计数法或者图着色算法进行全局寄存器分配。

首先我们先来介绍全局寄存器相较于临时寄存器的优点。临时寄存器的生存周期是一个基本块，当基本块结束时需要释放临时寄存器，而在下个基本块中如果需要再次使用到这个变量，则需要重新从内存中读取并写入寄存器。这种操作对于仅需使用一次的变量没什么影响，但是对于那些经常需要使用的变量，分配一个全局寄存器会比使用临时寄存器节省大量的存取内存的时间。

基于引用计数法分配全局寄存器的方法相对来说比较简单。以一个函数为一个全局域，统计该域内所有变量的引用次数，对于引用次数较多的变量则分配全局寄存器。在使用引用计数法统计变量的引用次数时，要注意调整循环变量的引用次数的权重，因为单纯的引用计数可能会减少循环变量的作用。

图着色法分配寄存器需要首先进行基本块划分与活跃变量分析。基本块的起始语句有三种情况：函数的第一条语句；跳转语句跳转到的语句；跳转语句之后的语句。活跃变量分析则是根据基本块的划分结果按照理论课上所学知识进行每个基本块的in、out、def、use集合，从而进行后续的图着色。

由于笔者在撰写这篇申优文档时，有部分优化工作尚未完成，因此在介绍全局寄存器优化相关内容时只是从理论角度进行了分析。



### 7.5 其他优化

以下都是一些细节之处的优化，故在此一并指出：

- 遇到`#T1=#T2+#T3;` `a=#T1;`这种情况可以简化为`a=#T2+#T3;`
- 删除无用代码，对于结果操作数在后文中没有再使用到的情况下，可以直接删除
- 对于循环语句，尽可能地使用beq和bne语句替换跳转语句以提高性能